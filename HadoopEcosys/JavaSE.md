★**switch中变量的类型有约束，记住类型**
case后只能是常量
default位置灵活，可以省略
f-else 和 switch-case转换
反向case穿透
*跳出循环 break和continue的区别*
**为循环命名，可用在内层循环中使用break结束外层循环**

***数组***
数组的内存分析栈、堆、方法区（常量池）
栈、堆、方法区（常量池）
**数组赋值数组，直接引用内存，二者内存和数组元素一致,画图表示**
栈、堆、方法区（常量池）
**数组赋值数组，直接引用内存，二者内存和数组元素一致,画图表示**

**数组赋值数组，直接引用内存，二者内存和数组元素一致,画图表示**

二分法查找
冒泡排序

***面向对象***

内存解析

匿名对象的特点和使用场景，

***学习方法***
1.代码
2.课后题
3.总结
4.工具总结xmind思维导图

值传递内存解析

局部变量存储在栈中，栈是先入后出

如果局部变量为引用数据类型，则栈内存放的是地址，

地址指向堆内所存储的内容

**值传递内存图三遍**

★★ ***String类型值传递***	▼存疑
String引用数据数据类型，但声明时没有new，数据存放在栈还是堆，是堆的话是不是因为定义类String时已经确定
字符串的声明（根据类String声明对象+赋值）
是堆的话是不是因为定义类String时已经确定了声明字符串即包含对象声明，即有“new”

**字符串比较避免空指针异常**

比较二维数组和对象数组，直接输出二维数组的元素和对象数组的元素，后者为地址，前者为？

数组形参与可变形参

★ ***引用数据类型值传递细节***   

调用方法时把A传递给引用数据类型形参B后，方法内部给形参B再赋值为另一个引用数据类型的C

**对象的关联** 在一个类中根据另一个类定义对象作为属性，一个对象中的属性存放另一个对象的地址值，内存解析

*包名的规范*     公司的域名反过来.项目名.模块名  每个点表示一层目录

四种权限修饰符所修饰的属性和方法对应的可调用范围

系统默认空参构造器

构造器可以重载

this关键字，形参名和属性名一致时通过this.修饰，调用同一个类时默认前面有隐藏this.

this();调用当前类中的空参构造器

this(形参列表);调用当前类的其他构造器，必须放在构造器的首行位置

每天先整理xmind

★父类中的私有属性，子类可以继承，但是可以通过继承到的方法来赋值或者获取

我们不认为子类可以继承父类的构造器

Java单继承
★在子类中通过调用父类的构造器，给父类的私有属性赋值

多态对象转换类型前仅能调用重写后的方法或者直接继承未被重写的父类方法

多态类型转换后（向下转型），可用于调用父类中未被重写的方法和子类中所有的方法（重写的方法和子类独有的对象），并不能调用父类中被重写覆盖的方法

instanceof用于判断对象是不是指定类的实例，

★★★在把多个方法封装为方法时，形参设置为父类对象，利用了子类方法重写的优势
★★★调用方法前声明对象时使用多态，利用了多态的优势

**==和equals的区别**

★equals 和 toString 的重写

类变量内存图

final关键字修饰引用数据类型，其地址不可变

方法内部代码块用于控制变量的生命周期

**★★★创建对象时的执行顺序**

​	1.调用
​	2.类加载
​		①静态代码块
​		②类信息
​	3.构造器

抽象类是为了**多态**的使用

▼ ★如果子类**未重写**抽象方法，多态调用方法
抽象方法所在的类必须是抽象类，子类直接继承抽象方法也不行
即，所有子类必须**重写**所有抽象父类的**全部**抽象方法
▲抽象类继承抽象父类后可以重写父类的抽象方法，也可以直接继承，一旦重写，非抽象子类可不再重写该方法

★内部类创建对象与调用外部属性与方法（静态，非静态）

成员内部类能不能被自己的外部类继承，能不能被外部其他类继承

常量命名规则，全大写，下划线隔开

多态中，父类引用指向子类的对象，该对象不可以通过转型来调用直接父类与间接父类的已经被重写过的方法。

接口冲突：（静态方法无冲突）默认方法

接口中方法的调用

匿名内部类的格式
匿名内部接口上实现类

```java
try{/*需要捕捉异常的代码段*/} catch(Exception e){/*异常处理*/} finally{/*遗言代码*/}
```

finally{ }中的代码在任何情形的运行终止前**都会执行**

String内存解析，常量池中的字符串复用

```java
String s = new String("xyz");//在内存中开辟了两块内存
indexOf(String str,int index);//index超出索引界限不会报错同样返回-1
String a = "xx" + "yy" + "zz";//只创建一个对象，只开辟了一块内存，只有常量参与运算则是编译时行为
```

★Collection中添加自定义类的对象，必须在该对象所在类中**重写**equals方法
foreach只出不进，可用局部变量传值输出或参与运算，并**不能**通过局部变量对数组或集合

★**Optional**预防**空指针**异常

★链表节点内存图

```java
String[] name = {"aa","bb"};
List list = Arrays.asList(name);//把数组转成集合
/*★创建ArrayList时的内存优化*/
new ArrayList();//底层创建一个长度为10的数组
```

LinkedList和Vector  API
ppt 24
★HashSet对象添加元素时的索引分配**内存解析**
equals比较结果相同，则hashCode值必须相同，参与比较的元素个数
equals比较的**严格**程度高于hashCode值比较

**HashMap**的的构造器和底层实现原理

**集合部分xMind**

ppt 66

使用**泛型通配符**时注意的问题

```java
double a = 1.0;
Double b = 1.0;
System.out.println(a == b);//是a自动装箱还是b自动拆箱
/*b自动拆箱，对调位置不影响*/
```

```java
ArrayList<String> arrayList = new ArrayList<String>();
arrayList.add("aaa");
arrayList.add("bbb");
List<?> list = arrayList;
list.add(null);
for (Object object : list)
    System.out.print(object);
for(String str : arrayList)
    System.out.print(str);
//运行结果：aaabbbnullaaabbbnull
```

```java
char x = 'x';
int a = 97;
System.out.println(true ? x : a);//120
System.out.println(true ? x : 97);//x
System.out.println(false ? x : 97);//a
```

**transien**t和**static**修饰的属性不能被序列化

native关键字

打印流修改输出管道

直接使用**匿名内部类**创建多线程

ppt 18 23 24 36 38

Thread.sleep();**放大**线程中暴露的问题
需要同步的线程的**同步监视器**必须**相同**
继承Thread的方式实现属性共享需要用**static**修饰，同步监视器不能用**this**
run() 方法内调用同步方法，同步方法默认监视器this，
继承方式的多线程会发生问题，需要static修饰同步方法，这时监视器是Thread子类的类信息（类名.class）
运行时类的对象

**懒汉**单例模式的**同步**改写

```java
yeild();//让资源，不起决定性作用
```

jconsole检测死锁

▼实现三线程交替输出100以内的数？

线程池作用

自定义注解

ClassLoader**双亲委派

```java
static{
    int a = 5;//静态代码块内的变量
}
int a , b;//属性
public static void main(String[] args){
    a = b++;//a = 0; b = 1;
    System.out.println(b++ + ++a);//1 + 1
}
```



